import { describe, it, expect, vi, beforeEach } from 'vitest'
import { generateFiles } from './cli.js'
import { rm, mkdir, writeFile, readFile } from 'fs/promises'
import path from 'path'

// Mock fs/promises
vi.mock('fs/promises', () => ({
  rm: vi.fn(),
  mkdir: vi.fn(),
  writeFile: vi.fn(),
  readFile: vi.fn().mockRejectedValue({ code: 'ENOENT' }),
}))

describe('generateFiles', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    // Reset the readFile mock to its default behavior for each test
    readFile.mockRejectedValue({ code: 'ENOENT' })
  })

  const mockPosts = [
    {
      id: 1,
      parent: 0,
      slug: 'handbook',
      link: 'https://make.wordpress.org/cli/handbook/',
      title: { rendered: 'Handbook Home' },
      content: { rendered: '<p>Welcome to the handbook!</p>' },
    },
    {
      id: 2,
      parent: 1,
      slug: 'installing',
      link: 'https://make.wordpress.org/cli/handbook/installing/',
      title: { rendered: 'Installing' },
      content: { rendered: '<h2>How to install</h2>' },
    },
  ]

  const rootItem = mockPosts.find((item) => parseInt(item.parent) === 0)
  const rootPath = rootItem.link.split(rootItem.slug)[0]

  it('should fetch posts and generate markdown files', async () => {
    global.fetch = vi.fn((url) => {
      if (url.includes('page=1')) {
        return Promise.resolve({
          ok: true,
          headers: new Map([['x-wp-totalpages', '1']]),
          json: () => Promise.resolve(mockPosts),
        })
      }
      return Promise.resolve({
        ok: true,
        headers: new Map([['x-wp-totalpages', '1']]),
        json: () => Promise.resolve([]),
      })
    })

    await generateFiles('cli', 'handbook', 'make', 'en', false)

    const expectedItemPath1 = (mockPosts[0].link.split(rootPath)[1].replace(/\/$/, '') || 'index')
    const finalPath1 = path.join('en', `${expectedItemPath1}.md`)
    const dirForFile1 = path.dirname(finalPath1)
    expect(mkdir).toHaveBeenCalledWith(dirForFile1, { recursive: true })
    expect(writeFile).toHaveBeenCalledWith(
      finalPath1,
      '# Handbook Home\n\nWelcome to the handbook!',
      { encoding: 'utf8' },
    )

    const expectedItemPath2 = mockPosts[1].link.split(rootPath)[1].replace(/\/$/, '')
    const finalPath2 = path.join('en', `${expectedItemPath2}.md`)
    const dirForFile2 = path.dirname(finalPath2)
    expect(mkdir).toHaveBeenCalledWith(dirForFile2, { recursive: true })
    expect(writeFile).toHaveBeenCalledWith(
      finalPath2,
      '# Installing\n\n## How to install',
      { encoding: 'utf8' },
    )
    expect(writeFile).toHaveBeenCalledTimes(2)
  })

  it('should handle API errors gracefully', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 500,
    })

    await expect(
      generateFiles('cli', 'handbook', 'make', 'en', false),
    ).rejects.toThrow('HTTP error! status: 500')
  })

  it('should remove output directory if regenerate is true', async () => {
    global.fetch = vi.fn((url) =>
      Promise.resolve({
        ok: true,
        headers: new Map([['x-wp-totalpages', '1']]),
        json: () => Promise.resolve(mockPosts),
      }),
    )

    await generateFiles('cli', 'handbook', 'make', 'en', true)

    expect(rm).toHaveBeenCalledWith('en', { recursive: true, force: true })
  })

  it('should update existing files with different content', async () => {
    global.fetch = vi.fn((url) =>
      Promise.resolve({
        ok: true,
        headers: new Map([['x-wp-totalpages', '1']]),
        json: () => Promise.resolve(mockPosts),
      }),
    )
    readFile.mockResolvedValue('old content')

    await generateFiles('cli', 'handbook', 'make', 'en', false)

    expect(writeFile).toHaveBeenCalledTimes(2)
  })

  it('should skip existing files with same content', async () => {
    global.fetch = vi.fn((url) =>
      Promise.resolve({
        ok: true,
        headers: new Map([['x-wp-totalpages', '1']]),
        json: () => Promise.resolve(mockPosts),
      }),
    )
    const expectedItemPath1 = (mockPosts[0].link.split(rootPath)[1].replace(/\/$/, '') || 'index')
    const finalPath1 = path.join('en', `${expectedItemPath1}.md`)

    // The markdown generated by turndown might have a trailing newline.
    const markdownForFile1 = '# Handbook Home\n\nWelcome to the handbook!'

    readFile.mockImplementation((p) => {
        if (p === finalPath1) {
            return Promise.resolve(markdownForFile1);
        }
        return Promise.reject({ code: 'ENOENT' });
    });


    await generateFiles('cli', 'handbook', 'make', 'en', false)

    expect(writeFile).toHaveBeenCalledTimes(1)
    const expectedItemPath2 = mockPosts[1].link.split(rootPath)[1].replace(/\/$/, '')
    const finalPath2 = path.join('en', `${expectedItemPath2}.md`)
    expect(writeFile).toHaveBeenCalledWith(
        finalPath2,
        '# Installing\n\n## How to install',
        { encoding: 'utf8' },
    )
  })

  it('should handle nested files correctly', async () => {
    const nestedMockPosts = [
      {
        id: 1,
        parent: 0,
        slug: 'handbook',
        link: 'https://make.wordpress.org/themes/handbook/',
        title: { rendered: 'Themes Handbook' },
        content: { rendered: '<p>Welcome</p>' },
      },
      {
        id: 2,
        parent: 1,
        slug: 'review',
        link: 'https://make.wordpress.org/themes/handbook/review/',
        title: { rendered: 'Review' },
        content: { rendered: '<p>Review process</p>' },
      },
      {
        id: 3,
        parent: 2,
        slug: 'required',
        link: 'https://make.wordpress.org/themes/handbook/review/required/',
        title: { rendered: 'Required' },
        content: { rendered: '<p>All requirements</p>' },
      },
    ];

    global.fetch = vi.fn((url) => {
      return Promise.resolve({
        ok: true,
        headers: new Map([['x-wp-totalpages', '1']]),
        json: () => Promise.resolve(nestedMockPosts),
      });
    });

    await generateFiles('themes', 'handbook', 'make', 'en-nested', false)

    expect(writeFile).toHaveBeenCalledTimes(3);

    const rootItem = nestedMockPosts.find((item) => parseInt(item.parent) === 0)
    const rootPath = rootItem.link.split(rootItem.slug)[0]

    const expectedItemPath1 = nestedMockPosts[0].link.split(rootPath)[1].replace(/\/$/, '')
    const finalPath1 = path.join('en-nested', `${expectedItemPath1}.md`)
    expect(writeFile).toHaveBeenCalledWith(finalPath1, '# Themes Handbook\n\nWelcome', { encoding: 'utf8' });

    const expectedItemPath2 = nestedMockPosts[1].link.split(rootPath)[1].replace(/\/$/, '')
    const finalPath2 = path.join('en-nested', `${expectedItemPath2}.md`)
    expect(writeFile).toHaveBeenCalledWith(finalPath2, '# Review\n\nReview process', { encoding: 'utf8' });

    const expectedItemPath3 = nestedMockPosts[2].link.split(rootPath)[1].replace(/\/$/, '')
    const finalPath3 = path.join('en-nested', `${expectedItemPath3}.md`)
    expect(writeFile).toHaveBeenCalledWith(finalPath3, '# Required\n\nAll requirements', { encoding: 'utf8' });
  });
})
